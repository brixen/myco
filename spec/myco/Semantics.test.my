
import 'BasicSpec.my'


BasicSpec {
  name: "Semantics"
  
  # Convenience function to return all passed arguments as an array
  unsplat: |*args| args
  # Convenience function to return the passed block
  unblock: |*args, &block| block
  # Convenience function to return all passed arguments including the block
  unsplat_w_block: |*args, &block| args.push(block)
  
  [tests]
  
  TestComponent < Object { var foo, var bar, var baz }
  
  "creates objects using new with optional keyword arguments": {
    obj = TestComponent.new(foo:1, bar:2)
    assert_equal(obj.foo, 1)
    assert_equal(obj.bar, 2)
    assert_equal(obj.baz, null)
  }
  
  "splats arguments in method calls": {
    skip
    a = [1,2]; b = [3,4]; c = [5,6]; d = [7,8]; e = [9,0]
    
    assert_equal(unsplat( a, b, c, d, e), [[1,2],[3,4],[5,6],[7,8],[9,0]])
    assert_equal(unsplat( a, b, c, d,*e), [[1,2],[3,4],[5,6],[7,8], 9,0 ])
    assert_equal(unsplat( a, b, c,*d,*e), [[1,2],[3,4],[5,6], 7,8,  9,0 ])
    assert_equal(unsplat(*a, b,*c, d,*e), [ 1,2, [3,4], 5,6, [7,8], 9,0 ])
    assert_equal(unsplat( a,*b, c,*d, e), [[1,2], 3,4, [5,6], 7,8, [9,0]])
    assert_equal(unsplat(*a,*b, c, d, e), [ 1,2,  3,4, [5,6],[7,8],[9,0]])
    assert_equal(unsplat(*a, b, c, d, e), [ 1,2, [3,4],[5,6],[7,8],[9,0]])
    assert_equal(unsplat(*a, b, c, d,*e), [ 1,2, [3,4],[5,6],[7,8], 9,0 ])
  }
  
  "splats arguments in array literals": {
    skip
    a = [1,2]; b = [3,4]; c = [5,6]; d = [7,8]; e = [9,0]
    
    # TODO: fix for case of array argument inline
    x = [ a, b, c, d, e]; assert_equal(x, [[1,2],[3,4],[5,6],[7,8],[9,0]])
    x = [ a, b, c, d,*e]; assert_equal(x, [[1,2],[3,4],[5,6],[7,8], 9,0 ])
    x = [ a, b, c,*d,*e]; assert_equal(x, [[1,2],[3,4],[5,6], 7,8,  9,0 ])
    x = [*a, b,*c, d,*e]; assert_equal(x, [ 1,2, [3,4], 5,6, [7,8], 9,0 ])
    x = [ a,*b, c,*d, e]; assert_equal(x, [[1,2], 3,4, [5,6], 7,8, [9,0]])
    x = [*a,*b, c, d, e]; assert_equal(x, [ 1,2,  3,4, [5,6],[7,8],[9,0]])
    x = [*a, b, c, d, e]; assert_equal(x, [ 1,2, [3,4],[5,6],[7,8],[9,0]])
    x = [*a, b, c, d,*e]; assert_equal(x, [ 1,2, [3,4],[5,6],[7,8], 9,0 ])
  }
  
  "passes a block to a method": {
    a = [1,2]; b = [3,4]; c = Proc.new { }
    
    refute(unblock)
    assert(unblock{})
    assert_equal(unblock(),      null)
    assert_equal(unblock(&null), null)
    assert_equal(unblock(&c),    c)
    assert_equal(unsplat_w_block(a,*b),       [[1,2], 3,4, null])
    assert_equal(unsplat_w_block(a,*b,&null), [[1,2], 3,4, null])
    assert_equal(unsplat_w_block(a,*b,&c),    [[1,2], 3,4, c])
  }
  
  "returns from a method 'early' with a jump return": {
    assert(true)
    88 ->         # Jump return the value 88
    assert(false) # This bad assertion is never reached
  }
  
  "returns a value from a method 'early' with a jump return": {
    value = send("returns from a method 'early' with a jump return")
    assert_equal(value, 88)
  }
}
