
Category < EmptyObject {
  # Forward unknown methods to parent
  method_missing: |sym, arg| { # TODO: use splat, handle any number of arguments
    instance_variable_get("@__parent_component__").instance.send(sym, arg)
  }
}

RubyEval < EmptyObject {
  from_string: |string| ::Kernel.instance_method(:eval).bind(self).call(string)
}

BasicObject < EmptyObject {
  # Basic conditional handling
  if:     |cond, &blk| cond && blk.call
  unless: |cond, &blk| cond || blk.call
  
  [decorators]
  
  # The 'var' decorator creates what is effectively an instance variable by:
  # 1) enabling memoization, keeping the given block from being re-run,
  #    unless run from an inheriting object (which would get its own "copy")
  # 2) TODO: prohibiting sending of any arguments
  # 3) TODO: creating a "writer" function in addition to the "reader"
  var: Decorator {
    apply: |meme| meme.memoize = true
  }
}

Decorator < BasicObject {
  # Implement the apply meme to decorate (mutate) the incoming meme
  apply: |meme| { }
  
  # TODO: Add vars to make basic transformations easy without implementing apply
}

Object < BasicObject {
  # Send the named signal to this object
  # TODO: support sending arguments with the signal
  __signal__: |name|
    decorators.on.signal_handlers.fetch(name, []).each |b| { b.result }
  
  [decorators]
  
  # Register a named signal handler
  # TODO: set meme.target to null
  var on: Decorator {
    var signal_handlers: Hash.new
    
    apply: |meme| {
      list = self.signal_handlers.fetch(meme.name, Array.new)
      list.push(meme)
      signal_handlers.send("[]=".to_sym, meme.name, list)
    }
  }
}
