
CodeTools::AST << {
  
  # These builder methods are copied directly from rubinius-processor
  # TODO: remove all dependencies on rubinius-processor and rubinius-ast
  BuilderMethods << {
    colon2: |loc, outer, name| {
      outer &? (
        (outer.kind_of?(ConstantAccess) && outer.name == :"Rubinius") &? (
          name == :"Type" &? (
            TypeConstant.new(loc.line)
          ) ?? (
            name == :"Mirror" &? (
              MirrorConstant.new(loc.line)
            ) ?? (
              ScopedConstant.new(loc.line, outer, name)
            )
          )
        ) ?? (
          ScopedConstant.new(loc.line, outer, name)
        )
      ) ?? (
        ConstantAccess.new(loc.line, name)
      )
    }
    
    colon3: |loc, name|
      ToplevelConstant.new(loc.line, name)
    
    lit: |loc, sym|
      SymbolLiteral.new(loc.line, sym)
    
    args: |loc, required, optional, splat, post, kwargs, kwrest, block|
      Parameters.new(loc.line, required, optional, splat, post, kwargs, kwrest, block)
    
    block: |loc, array|
      Block.new(loc.line, array)
    
    str: |loc, str|
      StringLiteral.new(loc.line, str)
    
    splat: |loc, expr|
      SplatValue.new(loc.line, expr)
    
    block_pass: |loc, arguments, body|
      BlockPass19.new(loc.line, arguments, body)
    
    evstr: |loc, value| {
      value &? (
        ToString.new(loc.line, value)
      ) ?? (
        StringLiteral.new(loc.line, "")
      )
    }
    
    dsym: |loc, str, array|
      DynamicSymbol.new(loc.line, str, array)
    
    dstr: |loc, str, array|
      DynamicString.new(loc.line, str, array)
    
    lasgn: |loc, name, value|
      LocalVariableAssignment.new(loc.line, name, value)
    
    hash: |loc, array|
      HashLiteral.new(loc.line, array)
    
    cdecl: |loc, expr, value|
      ConstantAssignment.new(loc.line, expr, value)
  }
  
  # Helper methods for bytecode generation
  ::CodeTools::Generator << {
    push_myco: push_cpath_top; find_const(:"Myco")
    push_void: push_myco;      find_const(:"Void")
    push_null: push_nil
  }
  
  # These builder methods process the null and void literals
  BuilderMethods << {
    self:  |loc| Self.new(line:loc.line)
    null:  |loc| NullLiteral.new(line:loc.line)
    void:  |loc| VoidLiteral.new(line:loc.line)
    true:  |loc| TrueLiteral.new(line:loc.line)
    false: |loc| FalseLiteral.new(line:loc.line)
  }
  
  Self < Node {
    to_sexp: [:self]
    bytecode: |g| pos(g); g.push_self
  }
  
  NullLiteral < Node {
    to_sexp: [:null]
    bytecode: |g| pos(g); g.push_null
  }
  
  VoidLiteral < Node {
    to_sexp: [:void]
    bytecode: |g| pos(g); g.push_void
  }
  
  TrueLiteral < Node {
    to_sexp: [:true]
    bytecode: |g| pos(g); g.push_true
  }
  
  FalseLiteral < Node {
    to_sexp: [:false]
    bytecode: |g| pos(g); g.push_false
  }
  
}
