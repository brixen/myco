%% name = CodeTools::PegParser
#%

%% { #%
  attr_accessor :processor
  attr_accessor :root_node
  
  # Generate an AST::Node of the given type (generated by the @processor)
  def node type, locator, *args
    @processor.send :"process_#{type}", locator.line, *args
  end
  
  # Generate a Token with the given type, text, and row_col
  def token type, text, row_col=nil
    row_col ||= [current_line, current_column-text.length]
    Token.new type, text, row_col
  end
  
  # A token is a lightweight unit of text with type and location info
  # as well as some convenience function for common conversion operations.
  class Token < BasicObject
    attr_accessor :type
    attr_accessor :text
    attr_accessor :line
    
    def inspect
      [@type, @text, @line].inspect
    end
    alias_method :to_s, :inspect
    
    def initialize type, text, row_col
      @type = type
      @text = text
      # TODO: integrate columns from location instead of just rows
      @line = row_col.first
    end
    
    def sym
      @text.to_sym
    end
  end
}

##
# Toplevel Terminal Categorizations

root = declobj_expr_body:n0  { @root_node = node(:declfile, n0, n0) }

declobj_expr =
  constant


##
# Character Classes

c_nl     = "\n"
c_spc    = /[ \t\r\f\v]/
c_spc_nl = c_spc | c_nl
c_ = c_spc

c_eof      = !.
c_eol      = c_nl | c_eof
c_any      = .

c_upper    = /[[:upper:]]/
c_lower    = /[[:lower:]]/ | "_"
c_alpha    = c_lower | c_upper
c_alnum    = c_alpha | /[0-9]/


##
# Tokens

t_EXPR_SEP    = < c_spc* (";" | c_nl) c_spc* >  ~token(:t_EXPR_SEP,    text)
t_DECLARE_END = < "}" | c_eof >                 ~token(:t_DECLARE_END, text)
t_SCOPE       = < "::" >                        ~token(:t_SCOPE,       text)

t_CONSTANT    = < (c_upper c_alnum*) >          ~token(:t_CONSTANT,    text)


##
# Object declarations

declobj_sepd_expr =
  t_EXPR_SEP:t_sep declobj_expr:n0  { n0 }
| t_EXPR_SEP:t_sep                  { nil }

declobj_sepd_exprs =
  declobj_sepd_exprs:nrest declobj_sepd_expr:n0  { [*nrest, n0].compact }
| declobj_sepd_expr:n0                           { [n0].compact }

declobj_expr_body =
  declobj_expr:n0 declobj_sepd_exprs:nrest t_DECLARE_END:t_end
      { node(:block, n0, [n0, *nrest]) }
| declobj_sepd_exprs:nrest t_DECLARE_END:t_end
      { nrest.empty? ? node(:null, t_end) : node(:block, nrest, nrest) }
| declobj_expr:n0 t_DECLARE_END:t_end
      { node(:block, n0, [n0]) }
| t_DECLARE_END:t_end
      { node(:null, t_end) }

##
# Constants

constant =
  constant:n0 t_SCOPE:ts t_CONSTANT:tc  ~node(:colon2, ts, n0, tc.sym)
| t_SCOPE:ts t_CONSTANT:tc              ~node(:colon3, ts, tc.sym)
| t_CONSTANT:tc                         ~node(:const,  tc, tc.sym)
