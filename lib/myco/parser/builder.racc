class MycoBuilder
  token T_CONSTANT T_IDENTIFIER
        T_NIL T_NUMERIC
        T_DEFINE T_COMMA T_DOT T_EXPR_SEP
        T_DECLARE_BEGIN T_DECLARE_END
        T_DECLSTR_BEGIN T_DECLSTR_END T_DECLSTR_BODY
        T_STRING_BEGIN  T_STRING_END  T_STRING_BODY
        T_BINDING_BEGIN T_BINDING_END
        T_PARAMS_BEGIN  T_PARAMS_END
        T_ARGS_BEGIN    T_ARGS_END

options no_result_var


rule
  main:
    declobj_expr
  ;
  
  
  declobj_expr:
    cdefn
  | cbind
  | bind
  | deco
  | declobj
  | declstr
  | constant
  ;
  
  bind_expr:
    declobj
  | declstr
  | arg_expr
  ;
  
  arg_expr:
    constant
  | call_with_args
  | id_as_lambig
  | lit_numeric
  | lit_nil
  | lit_string
  | dyn_string
  ;
  
  lit_nil:
    T_NIL          { ast(:nil, val[0]) }
  ;
  
  lit_numeric:
    T_NUMERIC      { ast(:lit, val[0], Integer(val[0][1])) }
  ;
  
  lit_string_body:
    T_STRING_BODY  { ast(:lit, val[0], encode_escapes(val[0][1])) }
  ;
  
  lit_string:
    T_STRING_BEGIN lit_string_body T_STRING_END { val[1] }
  ;
  
  dyn_string_parts:
    dyn_string_parts arg_expr lit_string { [*val[0], val[1], val[2]] }
  | arg_expr lit_string                  { [val[0], val[1]] }
  ;
  
  dyn_string:
    lit_string dyn_string_parts
      { ast(:dstr, val[0], val[0].value, val[1]) }
  ;
  
  id_as_symbol:
    T_IDENTIFIER
      { ast(:lit, val[0], val[0][1].to_sym) }
  ;
  
  id_as_lambig:
    T_IDENTIFIER
      { ast(:lambig, val[0], val[0][1].to_sym) }
  ;
  
  constant:
    T_CONSTANT
      { ast(:const, val[0], val[0][1].to_sym) }
  ;
  
  constant_list_:
    constant_list_ T_COMMA constant { [*val.first, val.last] }
  | constant                        { val }
  ;
  
  constant_list:
    constant_list_
      { ast(:array, val.first[0], val[0]) }
  ;
  
  call_with_args:
    T_IDENTIFIER arg_list
      { ast(:call, val[1], ast(:self, val[0]), val[0][1].to_sym, val[1]) }
  | arg_expr T_DOT T_IDENTIFIER arg_list
      { ast(:call, val[3], val[0], val[2][1].to_sym, val[3]) }
  | arg_expr T_DOT T_IDENTIFIER
      { ast(:call, val[2], val[0], val[2][1].to_sym, ast(:array, val[2], [])) }
  ;
  
  declobj_expr_body_:
    declobj_expr_body_ declobj_expr { [*val.first, val.last] }
  | declobj_expr                    { val }
  ;
  
  declobj_expr_body:
    declobj_expr_body_ T_DECLARE_END { ast(:block, val.first[0], val[0]) }
  | T_DECLARE_END                    { ast(:nil, val[0]) }
  ;
  
  bind_expr_body_:
    bind_expr_body_ T_EXPR_SEP bind_expr { [*val.first, val.last] }
  | bind_expr                            { val }
  ;
  
  bind_expr_body:
    bind_expr_body_ T_BINDING_END { ast(:block, val.first[0], val[0]) }
  | T_BINDING_END                 { ast(:nil, val[0]) }
  ;
  
  param:
    T_IDENTIFIER { val[0][1].to_sym }
  ;
  
  bind_param_list_:
    bind_param_list_ T_COMMA param { [*val.first, val.last] }
  | param                          { val }
  ;
  
  bind_param_list:
    T_PARAMS_BEGIN bind_param_list_ T_PARAMS_END  T_BINDING_BEGIN
      { ast(:args, val[0], val[1], nil, false, nil, nil) }
  | T_PARAMS_BEGIN T_PARAMS_END T_BINDING_BEGIN
      { ast(:args, val[0], [],     nil, false, nil, nil) }
  | T_BINDING_BEGIN
      { ast(:args, val[0], [],     nil, false, nil, nil) }
  ;
  
  arg_list_:
    arg_list_ T_COMMA arg_expr { [*val.first, val.last] }
  | arg_expr                   { val }
  ;
  
  arg_list:
    T_ARGS_BEGIN arg_list_ T_ARGS_END { ast(:array, val[0], val[1]) }
  | T_ARGS_BEGIN T_ARGS_END           { ast(:array, val[0], []) }
  ;
  
  declobj:
    constant_list T_DECLARE_BEGIN declobj_expr_body
      { ast(:declobj, val[1], val[0], val[2]) }
  ;
  
  declstr_body:
    T_DECLSTR_BODY
      { ast(:str, val[0], val[0][1]) }
  ;
  
  declstr:
    constant_list T_DECLSTR_BEGIN declstr_body T_DECLSTR_END
      { ast(:declstr, val[1], val[0], val[2]) }
  ;
  
  cdefn:
    constant T_DEFINE declobj
      { ast(:cdefn, val[1], val[0], val[2]) }
  ;
  
  cbind:
    constant T_BINDING_BEGIN bind_expr T_BINDING_END
      { ast(:cdecl, val[1], val[0], val[2]) }
  ;
  
  bind:
    id_as_symbol bind_param_list bind_expr_body
      { ast(:bind, val[1], val[0], nil, val[1], val[2]) }
  ;
  
  deco_able:
    bind
  | deco
  ;
  
  deco:
    T_IDENTIFIER deco_able
      {
        val[1].decorations.body.push ast(:lit, val[0], val[0][1].to_sym)
        val[1]
      }
  ;

---- inner
  attr_accessor :processor
  
  def parse string
    @tokens = Myco::ToolSet::Parser::Lexer.new(string).lex
    do_parse
  end
  
  def next_token
    tok = @tokens.shift
    [ tok[0], tok ] if tok
  end
  
  # Generate an AST::Node of the given type
  #
  # @param type [Symbol] The type of AST::Node to generate
  # @param locator [Array,AST::Node] The object from which to determine the
  #   source location where the AST::Node is to reference as its location.
  #   If it is an lexer token (Array), the location is pulled from it;
  #   if it is an AST::Node, the location for this node will be copied from it. 
  # @param args [Array] The arguments to pass to the processor method that
  #   will generate the AST::Node; usually the same as the arguments that will
  #   eventually be passed to the AST::Node's constructor.
  #
  def ast type, locator, *args
    line = locator.is_a?(Array) ? locator[2] : locator.line
    @processor.send :"process_#{type}", line, *args
  end
  
  def encode_escapes str
    str.gsub /\\(.)/ do "#{$1}" end
  end
