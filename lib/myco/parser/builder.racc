class CodeTools::Builder
  token T_CONSTANT T_IDENTIFIER T_SYMBOL
        T_NULL T_VOID T_TRUE T_FALSE
        T_INTEGER T_FLOAT
        T_SELF
        T_OP_PLUS T_OP_MINUS T_OP_MULT T_OP_DIV T_OP_MOD T_OP_EXP
        T_OP_COMPARE T_OP_AND T_OP_OR
        T_OP_TOPROC
        T_DOT T_QUEST
        T_DEFINE T_CONST_SEP T_EXPR_SEP T_ARG_SEP T_SCOPE T_ASSIGN
        T_DECLARE_BEGIN  T_DECLARE_END
        T_DECLSTR_BEGIN  T_DECLSTR_END  T_DECLSTR_BODY
        T_STRING_BEGIN   T_STRING_END   T_STRING_BODY
        T_SYMSTR_BEGIN   T_SYMSTR_END   T_SYMSTR_BODY
        T_CATEGORY_BEGIN T_CATEGORY_END T_CATEGORY_BODY
        T_MEME_BEGIN     T_MEME_END
        T_PARAMS_BEGIN   T_PARAMS_END
        T_ARGS_BEGIN     T_ARGS_END
        T_PAREN_BEGIN    T_PAREN_END
        T_ARRAY_BEGIN    T_ARRAY_END
        T_FILE_END

options no_result_var


prechigh
  left T_SCOPE
  left T_DOT T_QUEST
  left T_OP_EXP
  left T_OP_MULT T_OP_DIV T_OP_MOD
  left T_OP_PLUS T_OP_MINUS
  left T_OP_COMPARE
  left T_OP_AND T_OP_OR
  left T_ASSIGN
preclow


rule
  main:
    declobj_expr_body
  ;
  
  
  # Expressions allowable inside object declarations
  declobj_expr:
    cdefn
  | cmeme
  | meme
  | deco
  | declobj
  | declstr
  | category
  | constant
  ;
  
  # Expressions allowable inside memes
  meme_expr:
    declobj
  | declstr
  | arg_expr
  ;
  
  # Expressions allowable as function arguments
  arg_expr:
    arg_expr_atom
  | two_term_expr
  | assignment
  | nest_assignment
  | quest_self
  | lit_string
  | lit_symstr
  | dyn_string
  | dyn_symstr
  ;
  
  # Expressions allowable as function arguments and in other assemblies
  arg_expr_atom:
    paren_expr
  | call
  | quest
  | constant
  | id_as_lambig
  | lit_null
  | lit_void
  | lit_true
  | lit_false
  | lit_integer
  | lit_float
  | lit_symbol
  | lit_array
  | lit_self
  ;
  
  ##
  # Simple literals
  
  lit_null:
    T_NULL     { ast(:null, val[0]) }
  ;
  
  lit_void:
    T_VOID     { ast(:void, val[0]) }
  ;
  
  lit_true:
    T_TRUE     { ast(:true, val[0]) }
  ;
  
  lit_false:
    T_FALSE    { ast(:false, val[0]) }
  ;
  
  lit_integer:
    T_INTEGER  { ast(:lit, val[0], Integer(val[0][1])) }
  ;
  
  lit_float:
    T_FLOAT    { ast(:lit, val[0], Float(val[0][1])) }
  ;
  
  lit_symbol:
    T_SYMBOL   { ast(:lit, val[0], val[0][1].to_sym) }
  ;
  
  lit_string:
    T_STRING_BEGIN T_STRING_BODY T_STRING_END { val[1] }
      { ast(:lit, val[1], encode_escapes(val[1][1])) }
  ;
  
  lit_string_as_symbol: # Used in contexts where a bare string is a symbol
    T_STRING_BEGIN T_STRING_BODY T_STRING_END { val[1] }
      { ast(:lit, val[1], encode_escapes(val[1][1]).to_sym) }
  ;
  
  lit_symstr:
    T_SYMSTR_BEGIN T_SYMSTR_BODY T_SYMSTR_END
      { ast(:lit, val[1], encode_escapes(val[1][1]).to_sym) }
  ;
  
  lit_self:
    T_SELF { ast(:self, val[0]) }
  ;
  
  ##
  # String interpolations / juxtapositions
  
  dyn_string_part:
    arg_expr_atom lit_string { [ast(:evstr, val[0], val[0]), val[1]] }
  ;
  
  dyn_string_parts:
    dyn_string_parts dyn_string_part { [*val[0], *val[1]] }
  | dyn_string_part                  { val[0] }
  ;
  
  dyn_string:
    lit_string dyn_string_parts { ast(:dstr, val[0], val[0].value, val[1]) }
  ;
  
  dyn_symstr:
    lit_symstr dyn_string_parts { ast(:dsym, val[0], val[0].value.to_s, val[1])}
  ;
  
  ##
  # Constants
  
  constant:
    constant T_SCOPE T_CONSTANT { ast(:colon2, val[1], val[0], val[2][1].to_sym) }
  | T_SCOPE T_CONSTANT          { ast(:colon3, val[0], val[1][1].to_sym) }
  | T_CONSTANT                  { ast(:const,  val[0], val[0][1].to_sym) }
  ;
  
  constant_list_:
    constant_list_ T_CONST_SEP constant { [*val[0], val[2]] }
  | constant                            { val }
  ;
  
  constant_list:
    constant_list_
      { ast(:array, val[0][0], val[0]) }
  ;
  
  ##
  # Bare identifiers
  
  id_as_symbol: # Used in contexts where a bare identifier is a symbol
    T_IDENTIFIER
      { ast(:lit, val[0], val[0][1].to_sym) }
  ;
  
  id_as_lambig: # Ambiguous - could be local variable or call without args
    T_IDENTIFIER
      { ast(:lambig, val[0], val[0][1].to_sym) }
  ;
  
  ##
  # Assignment
  
  assignment:
    T_IDENTIFIER T_ASSIGN arg_expr
      { ast(:lasgn, val[1], val[0][1].to_sym, val[2]) }
  ;
  
  nest_assignment:
    arg_expr T_DOT T_IDENTIFIER T_ASSIGN arg_expr
      { ast(:call, val[3], val[0], :"#{val[2][1]}=", ast(:array, val[4], [val[4]])) }
  ;
  
  
  ##
  # Method calls
  
  call:
    nest_call
  | call_with_args
  | nest_call_with_args
  | call_iter
  | nest_call_iter
  ;
  
  nest_call:
    arg_expr T_DOT T_IDENTIFIER
      { ast(:call, val[2], val[0], val[2][1].to_sym, ast(:array, val[2], [])) }
  ;
  
  call_with_args:
    T_IDENTIFIER arg_list
      { ast(:call, val[1], ast(:self, val[0]), val[0][1].to_sym, val[1]) }
  ;
  
  nest_call_with_args:
    arg_expr T_DOT T_IDENTIFIER arg_list
      { ast(:call, val[3], val[0], val[2][1].to_sym, val[3]) }
  ;
  
  call_iter_body:
    T_MEME_BEGIN meme_expr_body
      { ast(:scope, val[0], nil, val[1], nil) }
  | param_list T_MEME_BEGIN meme_expr_body
      { ast(:scope, val[1], val[0], val[2], nil) }
  ;
  
  call_iter:
    T_IDENTIFIER call_iter_body
      { ast(:iter, val[0], ast(:call, val[0], ast(:self, val[0]), val[0][1].to_sym, nil),    val[1]) }
  | T_IDENTIFIER arg_list call_iter_body
      { ast(:iter, val[0], ast(:call, val[0], ast(:self, val[0]), val[0][1].to_sym, val[1]), val[2]) }
  ;
  
  nest_call_iter:
    arg_expr T_DOT T_IDENTIFIER call_iter_body
      { ast(:iter, val[2], ast(:call, val[2], val[0], val[2][1].to_sym, nil),    val[3]) }
  | arg_expr T_DOT T_IDENTIFIER arg_list call_iter_body
      { ast(:iter, val[2], ast(:call, val[2], val[0], val[2][1].to_sym, val[3]), val[4]) }
  ;
  
  ##
  # Method quests
  
  questable:
    T_IDENTIFIER
      { ast(:quest, val[0], ast(:self, val[0]), ast(:call, val[0], ast(:self, val[0]), val[0][1].to_sym, nil)) }
  | call_with_args
      { ast(:quest, val[0], ast(:self, val[0]), val[0]) }
  | call_iter
      { ast(:quest, val[0], ast(:self, val[0]), val[0]) }
  ;
  
  quest_self:
    T_QUEST questable { val[1] }
  ;
  
  quest:
    arg_expr_atom T_QUEST questable { val[2].receiver = val[0]; val[2] }
  ;
  
  ##
  # Argument lists
  
  splat:
    T_OP_MULT arg_expr_atom { ast(:splat, val[0], val[1]) }
  ;
  
  in_arg_expr:
    arg_expr
  | splat
  ;
  
  in_arg_sepd_expr:
    T_ARG_SEP                          { nil }
  | T_ARG_SEP in_arg_expr              { val[1] }
  ;
  
  in_arg_sepd_exprs:
    in_arg_sepd_exprs in_arg_sepd_expr { [*val[0], val[1]].compact }
  | in_arg_sepd_expr                   { val.compact }
  ;
  
  arg_list_:
    in_arg_expr in_arg_sepd_exprs T_ARGS_END { ast(:array, val[0], [val[0], *val[1]]) }
  | in_arg_sepd_exprs T_ARGS_END             { val[0].empty? ? ast(:null, val[1]) : ast(:array, val[0][0], val[0]) }
  | in_arg_expr T_ARGS_END                   { ast(:array, val[0], [val[0]]) }
  | T_ARGS_END                               { ast(:array, val[0], []) }
  ;
  
  arg_list:
    T_ARGS_BEGIN arg_list_ { splat_assemble(val[0], val[1]) }
  ;
  
  ##
  # Parameter lists
  
  param:
    T_IDENTIFIER
      { [:required, val[0][1].to_sym] }
  | T_IDENTIFIER T_ASSIGN arg_expr
      { [:optional, ast(:lasgn, val[1], val[0][1].to_sym, val[2])] }
  | T_OP_MULT T_IDENTIFIER
      { [:rest,  val[1][1].to_sym] }
  | T_OP_TOPROC T_IDENTIFIER
      { [:block, val[1][1].to_sym] }
  ;
  
  param_sepd:
    T_ARG_SEP param        { val[1] }
  | T_ARG_SEP              { nil }
  ;
  
  param_sepds:
    param_sepds param_sepd { [*val[0], val[1]].compact }
  | param_sepd             { val.compact }
  ;
  
  param_list_:
    param param_sepds T_PARAMS_END  { [val[0], *val[1]] }
  | param_sepds T_PARAMS_END        { val[0] }
  | param T_PARAMS_END              { [val[0]] }
  | T_PARAMS_END                    { [] }
  ;
  
  param_list:
    T_PARAMS_BEGIN param_list_
      {
        required, optional, rest, block = 4.times.map { Array.new }
        
        required << val[1].shift[1] while val[1][0] && val[1][0][0] == :required
        optional << val[1].shift[1] while val[1][0] && val[1][0][0] == :optional
        optional = optional.empty? ? nil : ast(:block, val[0], optional)
        rest     << val[1].shift[1] while val[1][0] && val[1][0][0] == :rest
        block    << val[1].shift[1] while val[1][0] && val[1][0][0] == :block
        
        ast(:args, val[0], required, optional, rest.first, nil, nil, nil, block.first)
      }
  ;
  
  ##
  # Array literals
  
  lit_array_:
    in_arg_expr in_arg_sepd_exprs T_ARRAY_END  { ast(:array, val[0], [val[0], *val[1]]) }
  | in_arg_sepd_exprs T_ARRAY_END              { val[0].empty? ? ast(:null, val[1]) : ast(:array, val[0][0], val[0]) }
  | in_arg_expr T_ARRAY_END                    { ast(:array, val[0], [val[0]]) }
  | T_ARRAY_END                                { ast(:array, val[0], []) }
  ;
  
  lit_array:
    T_ARRAY_BEGIN lit_array_ { splat_assemble(val[0], val[1]) }
  ;
  
  ##
  # Two-term operators
  
  two_term_expr:
    arg_expr T_OP_PLUS arg_expr
      { ast(:call, val[1], val[0], :'+', ast(:array, val[2], [val[2]])) }
  | arg_expr T_OP_MINUS arg_expr
      { ast(:call, val[1], val[0], :'-', ast(:array, val[2], [val[2]])) }
  | arg_expr T_OP_MULT arg_expr
      { ast(:call, val[1], val[0], :'*', ast(:array, val[2], [val[2]])) }
  | arg_expr T_OP_DIV arg_expr
      { ast(:call, val[1], val[0], :'/', ast(:array, val[2], [val[2]])) }
  | arg_expr T_OP_MOD arg_expr
      { ast(:call, val[1], val[0], :'%', ast(:array, val[2], [val[2]])) }
  | arg_expr T_OP_EXP arg_expr
      { ast(:call, val[1], val[0], :'**', ast(:array, val[2], [val[2]])) }
  | arg_expr T_OP_COMPARE arg_expr
      { ast(:call, val[1], val[0], val[1][1].to_sym, ast(:array, val[2], [val[2]])) }
  | arg_expr T_OP_AND arg_expr
      { ast(:and,  val[1], val[0], val[2]) }
  | arg_expr T_OP_OR arg_expr
      { ast(:or,   val[1], val[0], val[2]) }
  ;
  
  ##
  # Object declarations
  
  declobj_sepd_expr:
    T_EXPR_SEP declobj_expr              { val[1] }
  | T_EXPR_SEP                           { nil }
  ;
  
  declobj_sepd_exprs:
    declobj_sepd_exprs declobj_sepd_expr { [*val[0], val[1]].compact }
  | declobj_sepd_expr                    { val.compact }
  ;
  
  declobj_expr_body:
    declobj_expr declobj_sepd_exprs T_DECLARE_END  { ast(:block, val[0], [val[0], *val[1]]) }
  | declobj_sepd_exprs T_DECLARE_END               { val[0].empty? ? ast(:null, val[1]) : ast(:block, val[0][0], val[0]) }
  | declobj_expr T_DECLARE_END                     { ast(:block, val[0], [val[0]]) }
  | T_DECLARE_END                                  { ast(:null, val[0]) }
  ;
  
  declobj:
    constant_list T_DECLARE_BEGIN declobj_expr_body
      { ast(:declobj, val[1], val[0], val[2]) }
  ;
  
  cdefn:
    constant T_DEFINE declobj
      { ast(:cdefn, val[1], val[0], val[2]) }
  ;
  
  ##
  # String declarations
  
  declstr_body:
    T_DECLSTR_BODY
      { ast(:str, val[0], val[0][1]) }
  ;
  
  declstr:
    constant_list T_DECLSTR_BEGIN declstr_body T_DECLSTR_END
      { ast(:declstr, val[1], val[0], val[2]) }
  ;
  
  ##
  # Memes and etc..
  
  meme_sepd_expr:
    T_EXPR_SEP meme_expr           { val[1] }
  | T_EXPR_SEP                     { nil }
  ;
  
  meme_sepd_exprs:
    meme_sepd_exprs meme_sepd_expr { [*val[0], val[1]].compact }
  | meme_sepd_expr                 { val.compact }
  ;
  
  meme_expr_body:
    meme_expr meme_sepd_exprs T_MEME_END  { ast(:block, val[0], [val[0], *val[1]]) }
  | meme_sepd_exprs T_MEME_END            { val[0].empty? ? ast(:null, val[1]) : ast(:block, val[0][0], val[0]) }
  | meme_expr T_MEME_END                  { ast(:block, val[0], [val[0]]) }
  | T_MEME_END                            { ast(:null, val[0]) }
  ;
  
  paren_expr_body:
    meme_expr meme_sepd_exprs T_PAREN_END  { ast(:block, val[0], [val[0], *val[1]]) }
  | meme_sepd_exprs T_PAREN_END            { val[0].empty? ? ast(:null, val[1]) : ast(:block, val[0][0], val[0]) }
  | meme_expr T_PAREN_END                  { val[0] }
  | T_PAREN_END                            { ast(:null, val[0]) }
  ;
  
  paren_expr:
    T_PAREN_BEGIN paren_expr_body { val[1] }
  ;
  
  cmeme:
    constant T_MEME_BEGIN meme_expr_body
      { ast(:cdecl, val[1], val[0], val[2]) }
  ;
  
  meme_name:
    id_as_symbol
  | lit_string_as_symbol
  ;
  
  meme:
    meme_name param_list T_MEME_BEGIN meme_expr_body
      { ast(:meme, val[1], val[0], nil, val[1], val[3]) }
  | meme_name T_MEME_BEGIN meme_expr_body
      {
        args = ast(:args, val[0], [], nil, false, nil, nil, nil, nil)
        ast(:meme, val[1], val[0], nil, args, val[2])
      }
  ;
  
  deco_able:
    meme
  | deco
  ;
  
  deco:
    T_IDENTIFIER deco_able
      {
        val[1].decorations.body.push ast(:lit, val[0], val[0][1].to_sym)
        val[1]
      }
  ;
  
  category:
    T_CATEGORY_BEGIN T_CATEGORY_BODY T_CATEGORY_END
      { ast(:category, val[0], ast(:lit, val[1], val[1][1].to_sym)) }
  ;

---- inner
  attr_accessor :processor
  
  def parse string
    @tokens = Myco::ToolSet::Parser::Lexer.new(string).lex
    do_parse
  end
  
  def next_token
    tok = @tokens.shift
    [ tok[0], tok ] if tok
  end
  
  # Generate an AST::Node of the given type
  #
  # @param type [Symbol] The type of AST::Node to generate
  # @param locator [Array,AST::Node] The object from which to determine the
  #   source location where the AST::Node is to reference as its location.
  #   If it is an lexer token (Array), the location is pulled from it;
  #   if it is an AST::Node, the location for this node will be copied from it. 
  # @param args [Array] The arguments to pass to the processor method that
  #   will generate the AST::Node; usually the same as the arguments that will
  #   eventually be passed to the AST::Node's constructor.
  #
  def ast type, locator, *args
    # TODO: integrate columns from location instead of just rows
    line = locator.is_a?(Array) ? locator[2].first : locator.line
    @processor.send :"process_#{type}", line, *args
  end
  
  def encode_escapes str
    str.gsub /\\(.)/ do "#{$1}" end
  end
  
  # Given a locator and an ast(:array) node, refactor the splat-related nodes
  # in a copy of the original node body and return a replacement for the node.
  def splat_assemble loc, orig_node
    list = orig_node.body.dup
    tmp  = []
    
    splat_check = Proc.new { |x|
      case x
      when AST::SplatValue;   :splat
      when AST::ConcatArgs;   :argscat
      when AST::PushArgs;     :argspush
      else; nil
      end
    }
    
    # Get the original value in the new_node
    tmp << list.shift until list.empty? or splat_check.call(list.first)
    new_node = tmp.empty? ? list.shift : ast(:array, loc, tmp)
    
    # Continue to reduce until all elements have been used
    until list.empty?
      arg = list.shift
      if splat_check.call(arg)
        new_node = ast(:argscat, loc, new_node, arg)
      else
        new_node = ast(:argspush, loc, new_node, arg)
      end
    end
    
    new_node || orig_node
  end
