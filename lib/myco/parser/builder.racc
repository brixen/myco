class MycoBuilder
  token T_CONSTANT T_IDENTIFIER
        T_COMMA
        T_DECLARE_BEGIN T_DECLARE_END
        T_BINDING_BEGIN T_BINDING_END

options no_result_var


rule
  main:
    const_binding
  | declaration
  | constant
  ;
  
  
  constant:
    T_CONSTANT
      { ast(:const, val[0], val[0][1].to_sym) }
  ;
  
  constants_:
    constants_ T_COMMA constant { [*val.first, val.last] }
  | constant                    { val }
  ;
  
  constant_list:
    constants_
      { ast(:array, val.first[0], val[0]) }
  ;
  
  declaration:
    constant_list T_DECLARE_BEGIN T_DECLARE_END
      { ast(:declobj, val[1], val[0]) }
  ;
  
  expression:
    declaration
  | constant
  ;
  
  const_binding:
    constant T_BINDING_BEGIN expression T_BINDING_END
      { ast(:cdecl, val[1], val[0], val[2]) }
  ;

---- inner
  attr_accessor :processor
  
  def parse string
    @tokens = Myco::ToolSet::Parser::Lexer.new(string).lex
    do_parse
  end
  
  def next_token
    tok = @tokens.shift
    [ tok[0], tok ] if tok
  end
  
  # Generate an AST::Node of the given type
  #
  # @param type [Symbol] The type of AST::Node to generate
  # @param locator [Array,AST::Node] The object from which to determine the
  #   source location where the AST::Node is to reference as its location.
  #   If it is an lexer token (Array), the location is pulled from it;
  #   if it is an AST::Node, the location for this node will be copied from it. 
  # @param args [Array] The arguments to pass to the processor method that
  #   will generate the AST::Node; usually the same as the arguments that will
  #   eventually be passed to the AST::Node's constructor.
  #
  def ast type, locator, *args
    line = locator.is_a?(Array) ? locator[2] : locator.line
    @processor.send :"process_#{type}", line, *args
  end
