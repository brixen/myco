%% name = CodeTools::PegParser
#%

%% { #%
  attr_accessor :builder
  attr_accessor :root_node
  
  # Generate an AST::Node of the given type (generated by the @builder)
  def node type, locator, *args
    @builder.__send__ type, locator, *args
  end
  
  # Generate a Token with the given type, text, and row_col
  def token type, text, row_col=nil
    row_col ||= [current_line, current_column-text.length]
    Token.new type, text, row_col
  end
  
  # A token is a lightweight unit of text with type and location info
  # as well as some convenience function for common conversion operations.
  class Token
    attr_accessor :type
    attr_accessor :text
    attr_accessor :line
    
    def inspect
      [@type, @text, @line].inspect
    end
    alias_method :to_s, :inspect
    
    def initialize type, text, row_col
      @type = type
      @text = text
      # TODO: integrate columns from location instead of just rows
      @line = row_col.first
    end
    
    def sym;      @text.to_sym    end
    def float;    Float(@text)    end
    def integer;  Integer(@text)  end
  end
}

##
# Things to remember about PEG:
#
# Given the choice (a | b | c),
#   PEG will consume the first matching choice, not the longest.
# There is no ambiguity in PEG because all rule choices are order-dependent.
#   This means that you should avoid changing the order of choices
#   in a rule without being mindful of the consequences.
#
# Given a left-recursive set of rules such as
#   x = a | b | c
#   a = x "+" x
# PEG will silently ignore the 'a' rule when trying to contruct 'x' and
#   not even try to pursue it because it would result in infinite recursion.
#   To avoid left-recursion while retaining left-associativity,
#   use an iteration rule instead of a recursion rule.
#   (see the chained_left_atoms rule)


##
# Toplevel Terminal Categorizations

root = declobj_expr_body:n0  { @root_node = node(:declfile, n0, n0) }

# Declarations
decl =
  declobj
| declstr
| copen

# Expressions allowable inside object declarations
declobj_expr =
  category
| declobj_expr_not_category

# Expressions allowable inside object declarations that is not a category 
declobj_expr_not_category =
  decl
| cdefn
| cmeme
| constant
| meme

# Expressions allowable inside memes
meme_expr =
  arg_expr

# Expressions allowable as function arguments
arg_expr =
  assignment
| left_chained_atoms
| dyn_string
| dyn_symstr
| expr_atom

# TODO: make expr_atom not redundant with below rules
# Expression atoms
expr_atom =
  decl
| left_chained_invocations
| lit_string
| lit_symstr
| unary_operation
| paren_expr
| constant
| lit_simple
| lit_array
| invoke

# Expression atoms that are not invocation chains
expr_atom_not_chained =
  decl
| lit_string
| lit_symstr
| unary_operation
| paren_expr
| constant
| lit_simple
| lit_array
| invoke

# Expression atoms that are not strings
expr_atom_not_string =
  decl
| left_chained_invocations
| unary_operation
| paren_expr
| constant
| lit_simple
| lit_array
| invoke


##
# Character Classes

eol_comment = '#' (!c_eol .)*

c_nl     = "\n"
c_spc    = /[ \t\r\f\v]/ | "\\\n" | eol_comment
c_spc_nl = c_spc | c_nl

c_eof    = !.
c_eol    = c_nl | c_eof
c_any    = .

c_upper  = /[[:upper:]]/
c_lower  = /[[:lower:]]/ | "_"
c_num    = /[0-9]/
c_alpha  = c_lower | c_upper
c_alnum  = c_alpha | c_num
c_suffix = '!' | '?'


##
# Tokens

t_CONST_SEP     = < ',' >                     ~token(:t_CONST_SEP,     text)
t_EXPR_SEP      = < ';' | c_nl >              ~token(:t_EXPR_SEP,      text)
t_ARG_SEP       = < ',' | c_nl >              ~token(:t_ARG_SEP,       text)
t_DECLARE_BEGIN = < '{' >                     ~token(:t_DECLARE_BEGIN, text)
t_DECLARE_END   = < '}' | c_eof >             ~token(:t_DECLARE_END,   text)
t_MEME_MARK     = < ':' >                     ~token(:t_MEME_MARK,     text)
t_MEME_BEGIN    = < '{' >                     ~token(:t_MEME_BEGIN,    text)
t_MEME_END      = < '}' >                     ~token(:t_MEME_END,      text)
t_PAREN_BEGIN   = < '(' >                     ~token(:t_PAREN_BEGIN,   text)
t_PAREN_END     = < ')' >                     ~token(:t_PAREN_END,     text)
t_DEFINE        = < '<' >                     ~token(:t_DEFINE,        text)
t_REOPEN        = < '<<' >                    ~token(:t_REOPEN,        text)
t_PARAMS_BEGIN  = < '|' >                     ~token(:t_PARAMS_BEGIN,  text)
t_PARAMS_END    = < '|' >                     ~token(:t_PARAMS_END,    text)
t_ARGS_BEGIN    = < '(' >                     ~token(:t_ARGS_BEGIN,    text)
t_ARGS_END      = < ')' >                     ~token(:t_ARGS_END,      text)
t_ARRAY_BEGIN   = < '[' >                     ~token(:t_ARRAY_BEGIN,   text)
t_ARRAY_END     = < ']' >                     ~token(:t_ARRAY_END,     text)

t_CONSTANT      = < (c_upper c_alnum*) >      ~token(:t_CONSTANT,      text)
t_IDENTIFIER    = < (c_lower c_alnum*) c_suffix? >
                                              ~token(:t_IDENTIFIER,    text)
t_SYMBOL        = ':' < (c_lower c_alnum*) >  ~token(:t_SYMBOL,        text)

t_NULL          = < 'null' >                  ~token(:t_NULL,          text)
t_VOID          = < 'void' >                  ~token(:t_VOID,          text)
t_TRUE          = < 'true' >                  ~token(:t_TRUE,          text)
t_FALSE         = < 'false' >                 ~token(:t_FALSE,         text)
t_SELF          = < 'self' >                  ~token(:t_SELF,          text)
t_FLOAT         = < '-'? c_num+ '.' c_num+ >  ~token(:t_FLOAT,         text)
t_INTEGER       = < '-'? c_num+ >             ~token(:t_INTEGER,       text)

t_DOT           = < '.' >                     ~token(:t_DOT,           text)
t_QUEST         = < '.' c_spc_nl* '?' >       ~token(:t_QUEST,         text)
t_SCOPE         = < '::' >                    ~token(:t_SCOPE,         text)
t_ASSIGN        = < '=' >                     ~token(:t_ASSIGN,        text)
t_OP_TOPROC     = < '&' >                     ~token(:t_OP_TOPROC,     text)
t_OP_NOT        = < '!' >                     ~token(:t_OP_NOT,        text)
t_OP_PLUS       = < '+' >                     ~token(:t_OP_PLUS,       text)
t_OP_MINUS      = < '-' >                     ~token(:t_OP_MINUS,      text)
t_OP_MULT       = < '*' >                     ~token(:t_OP_MULT,       text)
t_OP_DIV        = < '/' >                     ~token(:t_OP_DIV,        text)
t_OP_MOD        = < '%' >                     ~token(:t_OP_MOD,        text)
t_OP_EXP        = < '**' >                    ~token(:t_OP_EXP,        text)
t_OP_AND        = < '&&' >                    ~token(:t_OP_AND,        text)
t_OP_OR         = < '||' >                    ~token(:t_OP_OR,         text)
t_OP_AND_Q      = < '&?' >                    ~token(:t_OP_AND_Q,      text)
t_OP_OR_Q       = < '|?' >                    ~token(:t_OP_OR_Q,       text)
t_OP_VOID_Q     = < '??' >                    ~token(:t_OP_VOID_Q,     text)
t_OP_COMPARE    = < ('<=>'|'=~'|'=='|'<='|'>='|'<'|'>') >
                                              ~token(:t_OP_COMPARE,    text)

string_norm = /[^\\\"]/
t_STRING_BODY   = < string_norm* ("\\" c_any string_norm*)* >
                                              ~token(:t_STRING_BODY,   text)
t_STRING_BEGIN  = < '"' >                     ~token(:t_STRING_BEGIN,  text)
t_STRING_END    = < '"' >                     ~token(:t_STRING_END,    text)
t_SYMSTR_BEGIN  = < ':"' >                    ~token(:t_SYMSTR_BEGIN,  text)

sstring_norm = /[^\\\']/
t_SSTRING_BODY  = < sstring_norm* ("\\" c_any sstring_norm*)* >
                                              ~token(:t_SSTRING_BODY,  text)
t_SSTRING_BEGIN = < "'" >                     ~token(:t_SSTRING_BEGIN, text)
t_SSTRING_END   = < "'" >                     ~token(:t_SSTRING_END,   text)

catgry_norm = /[^\\\[\]]/
t_CATGRY_BODY   = < catgry_norm* ("\\" c_any catgry_norm*)* >
                                              ~token(:t_CATGRY_BODY,   text)
t_CATGRY_BEGIN  = < '[' >                     ~token(:t_CATGRY_BEGIN,  text)
t_CATGRY_END    = < ']' >                     ~token(:t_CATGRY_END,    text)


##
# Simple literals

lit_simple =
  t_NULL:t0     ~node(:null,  t0)
| t_VOID:t0     ~node(:void,  t0)
| t_TRUE:t0     ~node(:true,  t0)
| t_FALSE:t0    ~node(:false, t0)
| t_SELF:t0     ~node(:self,  t0)
| t_FLOAT:t0    ~node(:lit,   t0, t0.float)
| t_INTEGER:t0  ~node(:lit,   t0, t0.integer)
| t_SYMBOL:t0   ~node(:lit,   t0, t0.sym)

##
# Enclosed literals

lit_string =
  t_STRING_BEGIN  t_STRING_BODY:tb  t_STRING_END
    ~node(:lit, tb, encode_escapes(tb.text))
| t_SSTRING_BEGIN t_SSTRING_BODY:tb t_SSTRING_END
    ~node(:lit, tb, encode_escapes(tb.text))

lit_string_as_symbol = # Used in contexts where a bare string is a symbol
  t_STRING_BEGIN  t_STRING_BODY:tb  t_STRING_END
    ~node(:lit, tb, encode_escapes(tb.text).to_sym)
| t_SSTRING_BEGIN t_SSTRING_BODY:tb t_SSTRING_END
    ~node(:lit, tb, encode_escapes(tb.text).to_sym)

lit_symstr =
  t_SYMSTR_BEGIN t_STRING_BODY:tb t_STRING_END
    ~node(:lit, tb, encode_escapes(tb.text).to_sym)

category_name = # Used only in declobj body
  t_CATGRY_BEGIN t_CATGRY_BODY:tb t_CATGRY_END
    ~node(:lit, tb, encode_escapes(tb.text).to_sym)

##
# String interpolations / juxtapositions

dyn_string_parts =
  (c_spc* expr_atom_not_string:n0 c_spc* lit_string:n1 {[n0,n1]})+:nlist
    { nlist.flatten }

dyn_string =
  lit_string:n0 dyn_string_parts:nrest
    ~node(:dstr, n0, [n0] + nrest)

dyn_symstr =
  lit_symstr:n0 dyn_string_parts:nrest
    ~node(:dsym, n0, [n0] + nrest)

##
# Constants

colon_const =
  t_SCOPE t_CONSTANT:tc
    { tc }

constant =
  t_SCOPE?:ts t_CONSTANT:tc (t_SCOPE t_CONSTANT:tx)*:trest
    ~node(:const, (ts||tc), !!ts, [tc.sym, *trest.map(&:sym)])

const_sep     = (c_spc_nl* t_CONST_SEP c_spc_nl*)+

constant_list =
  constant:n0 (const_sep constant:n)*:nrest
    ~node(:arrass, n0, [n0, *nrest])

##
# Bare identifiers

# Used in contexts where a bare identifier is a symbol
id_as_symbol =  t_IDENTIFIER:t0  ~node(:lit, t0, t0.sym)

##
# Object declarations

declobj_sepd_exprs =
  declobj_expr:n0 (arg_sep declobj_expr:n)*:nrest arg_sep_opt { [n0, *nrest] }

declobj_expr_body =
  arg_sep_opt declobj_sepd_exprs:nlist t_DECLARE_END:te
    ~node(:block, nlist.first, nlist)
| arg_sep_opt t_DECLARE_END:te
    ~node(:null, te)

declobj =
  constant_list:n0 c_spc_nl* t_DECLARE_BEGIN:t declobj_expr_body:n1
    ~node(:declobj, t, n0, n1)

category_expr =
  declobj_expr_not_category

category_sepd_exprs =
  arg_sep category_expr:n0 (arg_sep category_expr:n)*:nrest { [n0, *nrest] }

category =
  category_name:n0 category_sepd_exprs?:nlist &(arg_sep_opt (t_CATGRY_BEGIN | t_DECLARE_END))
    ~node(:category, n0, n0.value,
      (nlist ? node(:block, nlist.first, nlist) : node(:null, n0)))

copen =
  constant:n0 c_spc_nl* t_REOPEN:tb c_spc_nl* t_DECLARE_BEGIN declobj_expr_body:n1
    ~node(:copen, tb, n0, n1)

cdefn =
  constant:n0 c_spc_nl* t_DEFINE:t c_spc_nl* declobj:n1
    ~node(:cdefn, t, n0, n1)

##
# String object declarations

t_DECLSTR_BEGIN =
  < /[^\s{:,<][^\s]+/ >
    {
  
  # Table of replacement characters to use when calculating
  # the ending delimiter from the starting delimiter.
  # Directional characters are replaced with their opposite.
  @declstr_replace_tbl ||= %w{
    < > ( ) { } [ ]
  }
  
  # Calculate the ending delimiter to look for and store it
  @declstr_destrlim = text \
    .split(/(?<=[^a-zA-Z])|(?=[^a-zA-Z])/)
    .map { |str|
      idx = @declstr_replace_tbl.find_index(str)
      idx.nil? ? str : 
        (idx.odd? ? @declstr_replace_tbl[idx-1] : @declstr_replace_tbl[idx+1])
    }
    .reverse
    .join ''
  
  token(:t_DECLSTR_BEGIN, text)
}

t_DECLSTR_END =
  c_spc_nl* < (< /\S+/ > &{text == @declstr_destrlim}) >
    ~token(:t_DECLSTR_END, text)

s_DECLSTR_BODYLINE =
  < /[^\n]*\n/ >
    &{ text =~ /^(\s*)(\S+)/; $2!=@declstr_destrlim }
    { text }

s_DECLSTR_BODY =
  s_DECLSTR_BODYLINE*:slist
    { slist[1..-1].join('') }

declstr_body =
  t_DECLSTR_BEGIN:tb s_DECLSTR_BODY:st c_spc_nl* t_DECLSTR_END
    ~node(:str, tb, st)

declstr =
  constant_list:nc c_spc+ declstr_body:nb
    ~node(:declstr, nc, nc, nb)

##
# Assignment

assignment =
  local_assignment
| invoke_assignment

assign_rhs =
  arg_expr

local_assignment =
  t_IDENTIFIER:ti c_spc_nl* t_ASSIGN:to c_spc_nl* assign_rhs:rhs
    ~node(:lasgn, to, ti.sym, rhs)

invoke_assignment_lhs =
  left_chained_invocations
| invoke

invoke_assignment =
  invoke_assignment_lhs:lhs c_spc_nl* t_ASSIGN:to c_spc_nl* assign_rhs:rhs
    {
  lhs.name = :"#{lhs.name}="
  orig_arguments = lhs.arguments && lhs.arguments.body || []
  arg_order = lhs.name==:"[]=" ? [*orig_arguments, rhs] : [rhs, *orig_arguments]
  lhs.arguments = node(:argass, rhs, arg_order)
  lhs
}


##
# Invoke - Results in a :lambig, :call, or :iter with a :call within

invoke_body =
  (c_spc_nl* param_list:n)?:np c_spc_nl* meme_enclosed_expr_body:nb
    { [np, nb] }

invoke =
  t_IDENTIFIER:tn (c_spc* arg_list:na)?:na (c_spc_nl* invoke_body:n)?:nlist
    ~node(:invoke, tn, nil, tn.sym, na, *nlist)

op_invoke_id =
  left_op_normal

op_invoke = # Allow some binary operators to be invoked with a dot
  op_invoke_id:tn (c_spc* arg_list:na)?:na (c_spc_nl* invoke_body:n)?:nlist
    ~node(:invoke, tn, nil, tn.sym, na, *nlist)

elem_invoke =
  lit_array:na (c_spc_nl* invoke_body:n)?:nlist
    ~node(:invoke, na, nil, :"[]", node(:argass, na, na.body), *nlist)

##
# Argument lists

arg_sep     = (c_spc* t_ARG_SEP c_spc*)+
arg_sep_opt = (c_spc | t_ARG_SEP)*

in_arg_normal =
  in_arg_splat
| arg_expr:n0 !in_arg_kwarg_mark { n0 }

in_arg_normals =
  in_arg_normal:n0 (arg_sep in_arg_normal:n)*:nrest
    { [n0,*nrest] }

in_arg_kwargs =
  in_arg_kwarg:n0 (arg_sep in_arg_kwarg:n)*:nrest
    ~node(:hash, n0.first, [n0,*nrest].flatten)

in_arg_kwarg_mark = c_spc_nl* t_MEME_MARK:to
in_arg_kwarg =
  id_as_symbol:n0 in_arg_kwarg_mark c_spc_nl* arg_expr:n1
    { [n0, n1] }

in_arg_splat  =
  t_OP_MULT:to expr_atom:n0
    ~node(:splat, to, n0)

in_arg_block  =
  t_OP_TOPROC:to expr_atom:n0
    ~node(:blkarg, to, n0)

in_arg_list =
  in_arg_normals:n0 arg_sep in_arg_kwargs:n1 arg_sep in_arg_block:n2  { [*n0,n1,n2] }
| in_arg_normals:n0 arg_sep in_arg_kwargs:n1  { [*n0,n1] }
| in_arg_normals:n0 arg_sep in_arg_block:n1   { [*n0,n1] }
| in_arg_kwargs:n0  arg_sep in_arg_block:n1   { [n0, n1] }
| in_arg_normals:n0  { [*n0] }
| in_arg_kwargs:n0   { [n0] }
| in_arg_block:n0    { [n0] }

arg_list =
  t_ARGS_BEGIN:tb arg_sep_opt t_ARGS_END
    ~node(:argass, tb, [])
| t_ARGS_BEGIN:tb arg_sep_opt in_arg_list:nlist arg_sep_opt t_ARGS_END
    ~node(:argass, tb, nlist)

lit_array =
  t_ARRAY_BEGIN:tb arg_sep_opt t_ARRAY_END
    ~node(:arrass, tb, [])
| t_ARRAY_BEGIN:tb arg_sep_opt in_arg_list:nlist arg_sep_opt t_ARRAY_END
    ~node(:arrass, tb, nlist)

##
# Parameter lists

param =
  t_IDENTIFIER:ti c_spc_nl* t_ASSIGN:to c_spc_nl* arg_expr:nv
    { [:optional, node(:lasgn, ti, ti.sym, nv)] }
| t_IDENTIFIER:ti c_spc_nl* t_MEME_MARK:to c_spc_nl* arg_expr?:nv
    { [:kwargs, node(:lasgn, ti, ti.sym, (nv || node(:lit, to, :*)))] }
| t_OP_EXP c_spc_nl* t_IDENTIFIER:ti     { [:kwrest,   ti.sym] }
| t_OP_MULT c_spc_nl* t_IDENTIFIER:ti    { [:rest,     ti.sym] }
| t_OP_TOPROC c_spc_nl* t_IDENTIFIER:ti  { [:block,    ti.sym] }
| t_IDENTIFIER:ti                        { [:required, ti.sym] }

param_sepd =
  arg_sep param:n0  { n0 }

param_sepds =
  param:n0 (arg_sep param:n)*:nrest arg_sep_opt  { [n0, *nrest] }

param_list =
  t_PARAMS_BEGIN:tb t_PARAMS_END
    { node(:args, tb, [], [], nil, [], [], nil, nil) }
| t_PARAMS_BEGIN:tb param_sepds:plist t_PARAMS_END
    {
      required, optional, rest, post, kwargs, kwrest, block = 7.times.map { [] }
      
      required << plist.shift[1] while plist[0] && plist[0][0] == :required
      optional << plist.shift[1] while plist[0] && plist[0][0] == :optional
      rest     << plist.shift[1] while plist[0] && plist[0][0] == :rest
      post     << plist.shift[1] while plist[0] && plist[0][0] == :required
      kwargs   << plist.shift[1] while plist[0] && plist[0][0] == :kwargs
      kwrest   << plist.shift[1] while plist[0] && plist[0][0] == :kwrest
      block    << plist.shift[1] while plist[0] && plist[0][0] == :block
      
      required = required
      optional = optional
      rest     = rest.first
      post     = post
      kwargs   = kwargs
      kwrest   = kwrest.first
      block    = block.first
      
      # TODO: move these conversions to their respective reductions
      block = block && node(:blkprm, tb, block)
      
      node(:args, tb, required, optional, rest, post, kwargs, kwrest, block)
    }

##
# Two-term operators

left_op_normal =
  t_OP_EXP
| t_OP_MULT | t_OP_DIV | t_OP_MOD
| t_OP_PLUS | t_OP_MINUS
| t_OP_COMPARE

left_op_branch =
  t_OP_AND  | t_OP_OR
| t_OP_AND_Q | t_OP_OR_Q | t_OP_VOID_Q

left_op = left_op_normal | left_op_branch

# Achieve left-associativity through iteration.
#
# PEG parsers get tripped up by left recursion
# (in contrast to LALR parsers, which prefer left recursion).
# This is a well-understood limitation, but refer to:
# http://www.dalnefre.com/wp/2011/05/parsing-expression-grammars-part-4/
# for an easy-to-understand explanation of this problem and this solution.
#
left_chained_atoms =
  expr_atom:n0 (c_spc_nl* left_op:to c_spc_nl* expr_atom:n1 { [to, n1] })+:list
    {
  list.unshift n0
  list.flatten!
  
  collapse(list, :t_OP_EXP)
  collapse(list, :t_OP_MULT, :t_OP_DIV, :t_OP_MOD)
  collapse(list, :t_OP_PLUS, :t_OP_MINUS)
  collapse(list, :t_OP_COMPARE)
  collapse(list, :t_OP_AND, :t_OP_OR,
                 :t_OP_AND_Q, :t_OP_OR_Q, :t_OP_VOID_Q) do |n0,op,n1|
    node(:branch_op, op, op.sym, n0, n1)
  end
  
  # There should only be one resulting node left
  raise "Failed to fully collapse left_chained_atoms: #{list}" \
    unless list.count == 1
  
  list.first
}

##
# Invocations and Quests (soft-failing invocations)

left_invoke_op =
  t_QUEST
| t_DOT

# Achieve left-associativity through iteration.
# (see left_chained_atoms).
#
left_chained_invocation = 
  c_spc_nl* left_invoke_op:to c_spc_nl* (invoke | op_invoke):n1  { [to, n1] }
| c_spc* elem_invoke:n1                           { [token(:t_DOT, ""), n1] }

left_chained_invocations =
  expr_atom_not_chained:n0 left_chained_invocation+:list
    {
  list.unshift n0
  list.flatten!
  
  collapse(list, :t_DOT, :t_QUEST) do |n0,op,n1|
    op.type==:t_DOT ? (n1.receiver=n0; n1) : node(:quest, op, n0, n1)
  end
  
  # There should only be one resulting node left
  raise "Failed to fully collapse left_chained_invocations: #{list}" \
    unless list.count == 1
  
  list.first
}

##
# Unary operators

unary_operation =
  t_OP_NOT:to expr_atom:n0
    ~node(:invoke, to, n0, :"!", nil)

##
# Memes and etc..

t_inln_sep   = !t_ARG_SEP t_EXPR_SEP

inln_sep     = (c_spc* t_inln_sep c_spc*)+
inln_sep_opt = (c_spc | t_inln_sep)*

expr_sep     = (c_spc* t_EXPR_SEP c_spc*)+
expr_sep_opt = (c_spc | t_EXPR_SEP)*

meme_inline_sepd_exprs =
  meme_expr:n0 (inln_sep meme_expr:n)*:nrest inln_sep_opt  { [n0, *nrest] }

meme_sepd_exprs =
  meme_expr:n0 (expr_sep meme_expr:n)*:nrest expr_sep_opt  { [n0, *nrest] }

meme_inline_expr_body =
  inln_sep_opt meme_inline_sepd_exprs:nlist
    ~node(:block, nlist.first, nlist)

meme_expr_body =
  expr_sep_opt meme_sepd_exprs:nlist t_MEME_END:te
    ~node(:block, nlist.first, nlist)
| expr_sep_opt t_MEME_END:te
    ~node(:null, te)

paren_expr_body =
  expr_sep_opt meme_sepd_exprs:nlist t_PAREN_END:te
    { nlist.count==1 ? nlist.first : node(:block, nlist.first, nlist) }
| expr_sep_opt t_PAREN_END:te
    ~node(:null, te)

paren_expr =
  t_PAREN_BEGIN paren_expr_body:n0 { n0 }

meme_enclosed_expr_body =
  t_MEME_BEGIN meme_expr_body:n0   { n0 }

meme_either_body =
  meme_enclosed_expr_body
| meme_inline_expr_body

cmeme =
  constant:n0 c_spc* t_MEME_MARK:tm c_spc_nl* meme_inline_expr_body:n1
    ~node(:cdecl, tm, n0, n1)

meme_name =
  id_as_symbol
| lit_string_as_symbol

decorator =
  meme_name:ni arg_list?:na
    ~node(:deco, ni, ni, (na ? node(:arrass, na, na.body) : nil))

decorators_and_meme_name =
  decorator:n0 (c_spc* decorator:n)*:nrest
    ~node(:arrass, n0, [n0, *nrest].reverse)

meme =
  decorators_and_meme_name:nd c_spc* t_MEME_MARK:tm (c_spc_nl* param_list:n)?:np c_spc_nl* meme_either_body:nb
    ~node(:meme, tm, nd.body.shift.name, nd, np,  nb)
| decorators_and_meme_name:nd
    ~node(:meme, tm, nd.body.shift.name, nd, nil, nil)


%% {
#%
  # Encode escape characters in string literals
  # TODO: rigorously test and refine
  #
  def encode_escapes str
    str.gsub /\\(.)/ do
      case $1
      when "a"; "\a" # \a  0x07  Bell or alert
      when "b"; "\b" # \b  0x08  Backspace
      # TODO:        # \cx       Control-x
      # TODO:        # \C-x      Control-x
      when "e"; "\e" # \e  0x1b  Escape
      when "f"; "\f" # \f  0x0c  Formfeed
      # TODO:        # \M-\C-x   Meta-Control-x
      when "n"; "\n" # \n  0x0a  Newline
      # TODO:        # \nnn      Octal notation, where n is a digit
      when "r"; "\r" # \r  0x0d  Carriage return
      when "s"; "\s" # \s  0x20  Space
      when "t"; "\t" # \t  0x09  Tab
      when "v"; "\v" # \v  0x0b  Vertical tab
      # TODO:        # \xnn      Hexadecimal notation, where n is a digit
      else; "#{$1}"
      end
    end
  end
  
  # Given a node,op list ([node, op, node, op, ... node]) and operator types,
  # collapse the (node, op, node) groups where the operator is one of the types
  #
  # This function is meant to be called several times on the same list,
  # with a different set of operator types each time, in order of precedence.
  #
  def collapse input, *types
    output = []
    
    # Scan through, reducing or shifting based on the operator
    while input.count > 2
      n0 = input.shift
      op = input.shift
      
      if types.include? op.type
        n1 = input.shift
        
        result = block_given? ?
          yield(n0,op,n1) :
          node(:invoke, op, n0, op.sym, node(:argass, n1, [n1]))
        input.unshift result
      else
        output.push n0
        output.push op
      end
    end
    
    # Push the last item remaining
    output.push input.shift
    
    input.replace output
  end
}