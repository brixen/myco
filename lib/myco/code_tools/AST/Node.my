
CodeTools::AST << {
  
  Node < BasicObject {
    var loc
    
    pos: |g| g.set_line(self.loc[0])
    
    new_block_generator: |g, &block| {
      blk = g.class.new
      blk.name = g.state.name || :__block__
      blk.file = g.file
      blk.for_block = true
      
      blk.push_state(Scope.new(parent: g.state.scope))
      blk.definition_line(self.loc[0])
      blk.state.push_name(blk.name)
      pos(blk)
      
      block.call(blk)
      
      blk.ret
      blk.close
      
      blk.local_count = blk.state.scope.local_count
      blk.local_names = blk.state.scope.local_names
      
      blk.pop_state
      
      blk
    }
    
    static var fields:    []
    static var node_type:
      __name__.to_s.gsub(Ruby::Regexp.new("([a-z])([A-Z])"), "\\1_\\2").downcase.to_sym
    
    node_type: self.class.node_type
    fields:    self.class.fields
    representation: [
      self.node_type, self.loc, *self.fields.map |name| {
        value = __send__(name)
        value.?map |value| { value.?representation ?? value }
          ?? value.?representation
            ?? value
      }
    ]
    
    const is_data: false
    const has_loc_data: false
    
    data_array_visit: |item| {
      item.?data_array ?? (
        item &? (
          item.is_a?(Array) &? (
            item.map |subitem| { data_array_visit(subitem) }
          ) ?? item
        ) ?? null
      )
    }
    
    data_bytecode_visit: |g, item| {
      item.?data_bytecode(g) ?? (
        item &? (
          item.is_a?(Array) &? (
            item.each |subitem| { data_bytecode_visit(g, subitem) }
            g.make_array(item.size)
          ) ?? g.push_literal(item)
        ) ?? g.push_null
      )
    }
    
    data_array: {
      is_data || raise(""self" has no data_array implementation.")
      line_data = has_loc_data &? [self.loc] ?? []
      [self.node_type] + line_data + fields.map |field| {
        data_array_visit(__send__(field))
      }
    }
    
    data_bytecode: |g| {
      is_data || raise(""self" has no data_bytecode implementation.")
      g.push_literal(self.node_type)
      has_loc_data && g.push_loc(self.loc)
      fields.map |field| {
        data_bytecode_visit(g, __send__(field))
      }
      g.make_array(has_loc_data &? (2 + fields.size) ?? (1 + fields.size))
    }
    
    evaluate_bytecode: |g, evaluator=null| {
      pos(g)
      
      evaluator &? (
        evaluator.bytecode(g)
      ) ?? (
        g.push_myco
        g.find_const(:Evaluator)
      )
        g.push_scope; g.send(:myco_evctx, 0)
        self.data_bytecode(g)
      g.send(:evaluate, 2)
    }
    
    [decorators]
    
    const field: Decorator {
      apply: |meme| meme.target.fields.push(meme.name)
      [transforms]
      var: true
    }
  }
  
  Node << { Node: Node } # TODO: remove this hack
  
}
