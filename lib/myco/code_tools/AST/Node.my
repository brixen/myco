
CodeTools::AST << {
  
  Node < BasicObject {
    var loc
    
    pos: |g| g.set_line(self.loc[0])
    
    new_block_generator: |g, &block| {
      blk = g.class.new
      blk.name = g.state.name || :__block__
      blk.file = g.file
      blk.for_block = true
      
      blk.push_state(Scope.new(parent: g.state.scope))
      blk.definition_line(self.loc[0])
      blk.state.push_name(blk.name)
      pos(blk)
      
      block.call(blk)
      
      blk.ret
      blk.close
      
      blk.local_count = blk.state.scope.local_count
      blk.local_names = blk.state.scope.local_names
      
      blk.pop_state
      
      blk
    }
    
    static var fields:    []
    static var node_type:
      __name__.to_s.gsub(Ruby::Regexp.new("([a-z])([A-Z])"), "\\1_\\2").downcase.to_sym
    
    node_type: self.class.node_type
    fields:    self.class.fields
    representation: [
      self.node_type, self.loc, *self.fields.map |name| {
        value = __send__(name)
        value.?map |value| { value.?representation ?? value }
          ?? value.?representation
            ?? value
      }
    ]
    
    const is_data: false
    const has_loc_data: false
    
    data_array_visit: |item| {
      item.?data_array ?? (
        item &? (
          item.is_a?(Array) &? (
            item.map |subitem| { data_array_visit(subitem) }
          ) ?? item
        ) ?? null
      )
    }
    
    data_bytecode_visit: |g, item| {
      item.?data_bytecode(g) ?? (
        item &? (
          item.is_a?(Array) &? (
            item.each |subitem| { data_bytecode_visit(g, subitem) }
            g.make_array(item.size)
          ) ?? g.push_literal(item)
        ) ?? g.push_null
      )
    }
    
    data_array: {
      is_data || raise(""self" has no data_array implementation.")
      line_data = has_loc_data &? [self.loc] ?? []
      [self.node_type] + line_data + fields.map |field| {
        data_array_visit(__send__(field))
      }
    }
    
    data_bytecode: |g| {
      is_data || raise(""self" has no data_bytecode implementation.")
      g.push_literal(self.node_type)
      has_loc_data && g.push_loc(self.loc)
      fields.map |field| {
        data_bytecode_visit(g, __send__(field))
      }
      g.make_array(has_loc_data &? (2 + fields.size) ?? (1 + fields.size))
    }
    
    evaluate_bytecode: |g, evaluator=null| {
      pos(g)
      
      evaluator &? (
        evaluator.bytecode(g)
      ) ?? (
        g.push_myco
        g.find_const(:Evaluator)
      )
        g.push_scope; g.send(:myco_evctx, 0)
        self.data_bytecode(g)
      g.send(:evaluate, 2)
    }
    
    [decorators]
    
    const field: Decorator {
      apply: |meme| meme.target.fields.push(meme.name)
      [transforms]
      var: true
    }
  }
  
  # TODO: move this out of Node.my ?
  State < BasicObject {
    var scope
    
    # TODO: decouple rubinius-compiler from rubinius-ast and remove this hack
    static new: |scope| {
      obj = allocate
      obj.scope = scope
      obj
    }
    
    var names: [] # stack of names
    push_name: |x| self.names.push(x)
    pop_name:      self.names.pop
    name:          self.names.last
  }
  
  # TODO: move this out of Node.my ?
  Scope < CodeTools::Compiler::LocalVariables, BasicObject {
    var parent
    
    CompilerClass: CodeTools::Compiler # TODO: remove this
    
    # Look up a local variable in this block's scope.
    search_local: |name| {
      (variable = self.variables[name]) &? (
        variable.nested_reference
      ) ?? ((reference = self.parent && self.parent.search_local(name)) &? (
        reference.depth = reference.depth + 1
        reference
      ) ?? (
        null
      ))
    }
    
    # Assign a slot number to a new or retrieve an existing local variable.
    assign_local_reference: |name| {
      (variable = self.variables[name]) &? (
        variable.reference
      ) ?? ((reference = self.parent && self.parent.search_local(name)) &? (
        reference.depth = reference.depth + 1
        reference
      ) ?? (
        variable = self.new_local(name)
        variable.reference
      ))
    }
    
    new_local: |name| {
      self.variables[name] = \
        self.variables[name] || CompilerClass::LocalVariable.new(allocate_slot)
    }
  }
  
}
