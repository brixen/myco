
CodeTools::AST << {
  
  Invoke < Node {
    node_type invoke
    field receiver, field name, field arguments, field block
    
    bytecode: |g| pos(g); implementation.bytecode(g)
    
    implementation: {
      use_args = self.arguments
      
      # TODO: error if passing both block argument and block literal
      # Currently, this fails silently and ignores the block argument
      self.block && (
        use_args = (use_args && use_args.dup) || ArgumentAssembly.new(loc:self.loc, body:[])
        use_args.block = self.block
      )
      
      !self.receiver && !self.arguments && !self.block &? (
        LocalVariableAccessAmbiguous.new(
          loc: self.loc
          name: self.name
        )
      ) ?? (
        InvokeMethod.new(
          loc:       self.loc
          receiver:  self.receiver
          name:      self.name
          arguments: use_args
          block:     self.block
        )
      )
    }
    
    # TODO: don't be redundant with data_bytecode
    data_array: [:invoke,
      null, # TODO: receiver
      self.name,
      self.arguments.?to_literal ?? null, # TODO: data_array
      null, # TODO: block
    ]
    
    data_bytecode: |g| {
      g.push_literal(:invoke)
      g.push_null # TODO: receiver
      g.push_literal(self.name)
      self.arguments.?bytecode(g) ?? g.push_null # TODO: data_bytecode
      g.push_null # TODO: block
      g.make_array(5)
    }
  }
  
}
