
CodeTools::AST << {
  
  InvokeMethod < Node {
    node_type invoke_method
    field receiver, field name, field arguments, field block
    
    const is_data: true
    
    bytecode: |g| {
      receiver_bytecode(g)
      send_bytecode(g)
    }
    
    # Push the receiver object onto the stack.
    receiver_bytecode: |g| {
      self.receiver &? self.receiver.bytecode(g) ?? g.push_self
    }
    
    # Assumes that a receiver object is already at the top of the stack.
    send_bytecode: |g| {
      main_args  = self.main_args
      splat_arg  = self.splat_arg
      block      = self.block || self.block_arg
      
      send_count = main_args.size
      private    = !self.receiver
      
      splat_arg &? (
        main_args.each |item| { item.bytecode(g) }
        splat_arg.bytecode(g)
        block &? block.bytecode(g) ?? g.push_null
        g.send_with_splat(self.name, send_count, private)
      ) ?? (
        block &? (
          main_args.each |item| { item.bytecode(g) }
          block.bytecode(g)
          g.send_with_block(self.name, send_count, private)
        ) ?? (
          main_args.each |item| { item.bytecode(g) }
          g.send(self.name, send_count, private)
        )
      )
    }
    
    # Last argument if it is a BlockArgument
    block_arg:
      self.arguments.?last.is_a?(BlockArgument) &? self.arguments.last ?? null
    
    # All items before the first Splat
    main_args:
      self.arguments.?take_while |item| { !item.is_a?(Splat) &&
                                          !item.is_a?(BlockArgument) } ?? []
    
    # ArrayAssembly of all items after and including the first Splat
    splat_arg: {
      splat_arg_group =
        self.arguments.?drop_while |item| { !item.is_a?(Splat) }
                       .take_while |item| { !item.is_a?(BlockArgument) } ?? []
      
      splat_arg_group.any? &? (
        ArrayAssembly.new(
          loc: self.loc
          body: splat_arg_group
        )
      ) ?? null
    }
  }
  
}
