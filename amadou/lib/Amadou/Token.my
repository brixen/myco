
Amadou << {
  
  Token < BasicObject {
    var type
    var source
    var range
    
    static from: |type, source, start, stop| new(
      type:   type
      source: source
      range:  ::Ruby::Range.new(start, stop, true)
    )
    
    text: source[range]
    
    sym:              text.to_sym
    float:            text.to_f
    integer: |base=0| text.to_inum(base, true)
    
    inspect: "#<"self.class" "type.inspect" "text.inspect">"
    
    representation: [type, text]
    
    # Given a string, return a map of indices of newline positions to line numbers
    static memoize line_map_for: |string| {
      idx_hash = ::Ruby::Hash.new
      idx_hash[0] = 0
      count = 0
      idx = -1
      Ruby.__send__(:loop) { # TODO: Loop.run
        idx = string.index("\n", idx + 1)
        idx || Ruby.__send__(:raise, ::Ruby::StopIteration) # TODO: Loop.break
        count = count + 1
        idx_hash[idx] = count
      }
      idx_hash
    }
    
    # Given an index and string, return the row (line) and column numbers
    static position_of: |idx, string| {
      nl_idx = string.rindex("\n", idx) || 0
      row = Token.line_map_for(string).fetch(nl_idx) + 1
      col = idx - nl_idx
      [row, col]
    }
    
    var position: self.class.position_of(range.first, source)
    row: position.first
    col: position.last
    line: row
  }
  
}
