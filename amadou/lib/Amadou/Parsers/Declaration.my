
Amadou << {
  Parsers << {
    
    Declaration: Base {
      parse: |group| {
        output = []
        
        group.phrases.each |phrase| {
          state = parser.parse(phrase.list)
          state.end_idx || raise("No known meaning for declaration phrase: "phrase.inspect"")
          result = state.result[:root]
          handlers.__send__(result.first, output, result.last)
        }
        
        output
      }
      
      const parser: Pegleromyces::Stream::Parser {
        const grammar: Pegleromyces::Grammar {
          const local_word_pattern: Regexp.new("^([[:lower:]]|_)")
          const paren_pattern:      Regexp.new("\\(")
          
          s:            si([:tagged?, [:space], true])
          glyph: |text| si([:tagged?, [:glyph], true], [:text, [], text])
          word:         si([:tagged?, [:word],  true])
          local_word:   si([:tagged?, [:word],  true]
                           [:match?,  [local_word_pattern], true])
          paren_group:  si([:tagged?, [:group], true]
                           [:start_match?, [paren_pattern], true])
          
          [rules]
          rule root: (
              r(none)       { [:none,       captures] }
            / r(empty_meme) { [:empty_meme, captures] }
          )[:root]
          
          rule none:        s+esi
          rule empty_meme:  s+ name.+[:names] +esi
          
          rule name:
            r(word[:name] + s + paren_group[:args] + s) { [name, args] }
          / r(word[:name] + s)                          { [name, null] }
        }
      }
      
      [handlers]
      
      none: {}
      
      empty_meme: |output, names:| {
        first_name = names.first.first
        output.push(ast.meme(first_name,
          ast.array(first_name, names.map |name, args| {
            args &? (
              args = ast.args(args.start, Parsers::Sequence.parse(args).array)
              ast.invoke(name, null, name.sym, args, null)
            ) ?? (
              ast.symbol(name, name.sym)
            )
          })
        ))
      }
    }
    
  }
}
